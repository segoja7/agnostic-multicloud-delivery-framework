"""
Policy Scaffolder for AMDF

Generates KCL policy templates based on CRD structure analysis.
Helps users create custom policies when official Kyverno policies are not available.
"""

from typing import Dict, Any, List
import textwrap

class PolicyScaffolder:
    """Analyzes CRD schema and generates a KCL policy mixin template"""

    def generate(self, kind: str, schema_def: Dict[str, Any]) -> str:
        """
        Generate KCL policy code
        
        Args:
            kind: The Resource Kind (e.g. "Backup")
            schema_def: The JSON schema definition of the resource
            
        Returns:
            String containing the KCL schema code
        """
        checks = []
        
        # Navigate to spec properties if they exist
        # Schema structure varies, usually it's definitions -> Kind -> properties -> spec
        spec_props = {}
        
        # Try to find spec properties in the passed schema definition
        if 'properties' in schema_def and 'spec' in schema_def['properties']:
            spec_schema = schema_def['properties']['spec']
            if 'properties' in spec_schema:
                spec_props = spec_schema['properties']
            # Handle referenced spec (if resolved)
            elif 'items' in spec_schema: # Rare for spec to be array, but safe check
                pass
        
        # If we couldn't find spec props easily, try to iterate top level props that aren't metadata
        if not spec_props:
             spec_props = {k: v for k, v in schema_def.get('properties', {}).items() 
                          if k not in ['apiVersion', 'kind', 'metadata', 'status']}

        for field, props in spec_props.items():
            field_checks = self._generate_checks_for_field(field, props)
            if field_checks:
                checks.extend(field_checks)

        # Generate the file content
        policy_name = f"{kind}PolicyMixin"  # Changed: Add Mixin suffix
        
        # Indent checks
        formatted_checks = "\n".join([f"        {c}" for c in checks])
        
        if not formatted_checks:
            formatted_checks = "        True  # No specific fields detected for auto-generation"

        # If all checks are commented, add a placeholder
        if formatted_checks and all(line.strip().startswith('#') or not line.strip() for line in formatted_checks.split('\n')):
            formatted_checks += "\n        True  # Placeholder - uncomment checks above to enable validation"
        
        # If no checks at all, add default
        if not formatted_checks.strip():
            formatted_checks = "        True  # No specific fields detected for auto-generation"

        template = f'''"""
Auto-generated Policy Template for {kind}
Generated by AMDF Policy Scaffolder.

This is a starting point for creating custom policies. 
Uncomment the checks you want to enforce.

IMPORTANT: All checks below are commented out by default. 
To enable validation, uncomment the checks you need.
"""

schema {policy_name}:
    """
    Validation rules for {kind}.
    
    Usage:
        import blueprints.{kind}
        import policies.{kind}Policy
        
        # Create a validated schema that inherits from the blueprint
        schema Validated{kind}({kind}.{kind}Blueprint):
            mixin [{kind}Policy.{policy_name}]
        
        # Use the validated schema
        resource = Validated{kind} {{
            # ... configuration ...
        }}
    
    Example - Enable TTL validation:
        Uncomment the ttl check below to enforce TTL requirement.
    """
    
    # Define structure to access fields (Partial schema)
    spec: {{str:any}}
    
    check:
{formatted_checks}
'''
        return template

    def _generate_checks_for_field(self, field: str, props: Dict[str, Any]) -> List[str]:
        """Generate check suggestions based on field type and name"""
        checks = []
        field_type = props.get('type', 'any')
        desc = props.get('description', 'No description').split('.')[0] + "."
        
        # Clean description for comment
        desc = desc.replace('\n', ' ')
        
        prefix = f"# [{field}] ({field_type}): {desc}"
        
        # 1. Image fields (Security)
        if "image" in field.lower() and field_type == "string":
            checks.append(f"{prefix}")
            checks.append(f"# Suggestion: Enforce specific registry or forbid latest")
            checks.append(f"# not spec.{field}.endswith(\":latest\"), \"{field} cannot use mutable tag 'latest'\"")
            checks.append(f"# spec.{field}.startswith(\"my-registry.io/\"), \"{field} must come from trusted registry\"")
            checks.append("") # Spacer

        # 2. Replicas / Counts (Integer ranges)
        elif field_type == "integer":
            checks.append(f"{prefix}")
            checks.append(f"# Suggestion: Enforce reasonable limits")
            checks.append(f"# spec.{field} >= 1, \"{field} must be at least 1\"")
            checks.append(f"# spec.{field} <= 10, \"{field} cannot exceed 10\"")
            checks.append("")

        # 3. Enum-like Strings (if enum is present)
        elif field_type == "string" and "enum" in props:
            options = props['enum']
            checks.append(f"{prefix}")
            checks.append(f"# Suggestion: Allowed values are {options}")
            checks.append(f"# spec.{field} in {options}, \"Invalid value for {field}\"")
            checks.append("")

        # 4. Generic Strings (Required/Pattern)
        elif field_type == "string":
            checks.append(f"{prefix}")
            checks.append(f"# Suggestion: Ensure it is set")
            checks.append(f"# \"{field}\" in spec, \"{field} is required\"")
            checks.append(f"# spec.{field} != \"\", \"{field} cannot be empty\"")
            checks.append("")

        # 5. Arrays (Non-empty)
        elif field_type == "array":
            checks.append(f"{prefix}")
            checks.append(f"# Suggestion: List validation")
            checks.append(f"# len(spec.{field}) > 0, \"{field} list cannot be empty\"")
            checks.append("")
            
        # 6. Boolean (Specific state)
        elif field_type == "boolean":
            checks.append(f"{prefix}")
            checks.append(f"# Suggestion: Enforce state")
            checks.append(f"# spec.{field} == True, \"{field} must be enabled\"")
            checks.append("")

        return checks



def generate_main_k_template(crd_kind: str, has_policies: bool) -> str:
    """
    Generate a main.k template file with usage examples
    
    Args:
        crd_kind: The resource kind (e.g., "Backup", "ResourceGraphDefinition")
        has_policies: Whether policy scaffold was generated
        
    Returns:
        Content for main.k file
    """
    if has_policies:
        return f'''"""
Example: Using {crd_kind}

This file demonstrates how to use the generated blueprint with optional policy validation.
"""

import blueprints.{crd_kind}
import policies.{crd_kind}Policy

# Option 1: Basic usage without validation
# Uncomment to use:
# my{crd_kind} = {crd_kind}.{crd_kind}Blueprint {{
#     _metadataName = "my-{crd_kind.lower()}"
#     _namespace = "default"
#     _labels = {{app = "my-app"}}
#     # TODO: Add required fields here
# }}

# Option 2: With policy validation (recommended)
# Create a validated schema that inherits from the blueprint
schema Validated{crd_kind}({crd_kind}.{crd_kind}Blueprint):
    mixin [{crd_kind}Policy.{crd_kind}PolicyMixin]

# Create an instance with validation
my{crd_kind} = Validated{crd_kind} {{
    _metadataName = "my-{crd_kind.lower()}"
    _namespace = "default"
    _labels = {{app = "my-app"}}
    # TODO: Add required fields here
    # Check the blueprint file for available fields
}}

# Output the resources
items = [my{crd_kind}]
'''
    else:
        return f'''"""
Example: Using {crd_kind}

This file demonstrates how to use the generated blueprint.
"""

import blueprints.{crd_kind}

# Create a {crd_kind} resource
my{crd_kind} = {crd_kind}.{crd_kind}Blueprint {{
    _metadataName = "my-{crd_kind.lower()}"
    _namespace = "default"
    _labels = {{app = "my-app"}}
    # TODO: Add required fields here
    # Check the blueprint file for available fields
}}

# Output the resources
items = [my{crd_kind}]
'''


def generate_k8s_policy_template(kind: str) -> str:
    """
    Generate a policy template for native Kubernetes resources
    
    Args:
        kind: Kubernetes kind (e.g., "Pod", "Deployment")
    
    Returns:
        KCL policy template code
    """
    # Common checks based on resource type
    common_checks = {
        "Pod": [
            "# Security: Disallow privileged containers",
            '        # all container in _containers { not (container?.securityContext?.privileged == True) }, "Privileged containers not allowed"',
            "        ",
            "        # Security: Require non-root user",
            '        # all container in _containers { container?.securityContext?.runAsNonRoot == True }, "Containers must run as non-root"',
            "        ",
            "        # Best practice: Disallow latest tag",
            '        # all container in _containers { not container.image.endswith(":latest") }, "Using :latest tag is not allowed"',
            "        ",
            "        # Resource limits",
            '        # all container in _containers { "memory" in (container?.resources?.limits or {}) }, "Memory limits required"',
        ],
        "Deployment": [
            "# Replicas validation",
            '        # _replicas >= 2, "Minimum 2 replicas required for high availability"',
            "        ",
            "        # Security: Disallow privileged containers",
            '        # all container in _template.spec.containers { not (container?.securityContext?.privileged == True) }, "Privileged containers not allowed"',
            "        ",
            "        # Best practice: Require resource limits",
            '        # all container in _template.spec.containers { "memory" in (container?.resources?.limits or {}) }, "Memory limits required"',
        ],
        "Service": [
            "# Type validation",
            '        # _type in ["ClusterIP", "NodePort", "LoadBalancer"], "Invalid service type"',
            "        ",
            "        # Port validation",
            '        # len(_ports) > 0, "At least one port must be defined"',
        ],
    }
    
    checks = common_checks.get(kind, [
        "# Add your custom validation checks here",
        "        # Example:",
        '        # "required-label" in _labels, "Required label missing"',
    ])
    
    checks_str = "\n".join(checks)
    
    return f'''"""
Custom Policy Template for {kind}

This file provides a template for adding custom validation checks.
Uncomment and modify the checks below based on your requirements.

To use this policy:
1. Uncomment the checks you want to enforce
2. Modify values to match your requirements
3. Add new checks as needed
4. Use the mixin in your main.k file

For Kyverno policy validation, use: amdf validate manifest.yaml --cluster
"""

schema {kind}PolicyMixin:
    """
    Custom validation checks for {kind} resources.
    
    These checks run at compile-time in KCL.
    For runtime validation, use Kyverno policies in your cluster.
    """
    
    check:
        # Placeholder check (ensures compilation without errors)
        True
        
        # ===== CUSTOM CHECKS =====
        # Uncomment and modify the checks below:
        
        {checks_str}
        
        # ===== ADD YOUR OWN CHECKS =====
        # Examples:
        # - Namespace restrictions
        # - Label requirements
        # - Resource limits
        # - Security policies
        # - Naming conventions
'''
